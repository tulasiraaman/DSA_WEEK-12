class Solution {
    public ArrayList<Integer> bfs(ArrayList<ArrayList<Integer>> adj) {
        // Step 1: Convert adj into a Map<Integer, LinkedList<Integer>>
        Map<Integer, LinkedList<Integer>> adjMap = new HashMap<>();
        int j = 0;

        for (ArrayList<Integer> arr : adj) {
            adjMap.putIfAbsent(j, new LinkedList<>());
            for (int i = 0; i < arr.size(); i++) {
                adjMap.get(j).add(arr.get(i));
            }
            j++;
        }

        // Step 2: BFS traversal
        ArrayList<Integer> result = new ArrayList<>();
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        
        queue.add(0);
        visited.add(0);

        while(!queue.isEmpty()){
            int node = queue.poll();
            result.add(node);
            
            for(int neighbor : adjMap.getOrDefault(node, new LinkedList<>())){
                if(!visited.contains(neighbor)){
                    visited.add(neighbor);
                    queue.add(neighbor);
                }
            }
        }
        
        return result;
    }
    // TC - O(V + E), SC - O(V + E)
}
